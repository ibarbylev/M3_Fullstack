# Чек-лист инструментов и приёмов оптимизации агрегаций в Django

---

## **1. Планирование и агрегации**

| Приём                    | Как использовать                                                                                                | Зачем                                                 |
| ------------------------ | --------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------- |
| `annotate`               | `Author.objects.annotate(book_count=Count('book'))`                                                             | Счётчики и агрегаты на уровне SQL, без Python-обходов |
| `aggregate`              | `Book.objects.aggregate(avg_rating=Avg('rating'))`                                                              | Общие значения (сумма, среднее, минимум, максимум)    |
| `values` / `values_list` | `Author.objects.values('country').annotate(count=Count('id'))`                                                  | Выгружаем только нужные поля, экономим память         |
| `Subquery` / `OuterRef`  | `Subquery(Book.objects.filter(author=OuterRef('pk')).values('author').annotate(cnt=Count('id')).values('cnt'))` | Сложные агрегации без множества запросов              |

---

## **2. Оптимизация связей**

| Приём              | Пример                                     | Примечание                                                                 |
| ------------------ | ------------------------------------------ | -------------------------------------------------------------------------- |
| `select_related`   | `Book.objects.select_related('author')`    | Для `ForeignKey` / `OneToOne`, уменьшает N+1 запросы                       |
| `prefetch_related` | `Author.objects.prefetch_related('books')` | Для `ManyToMany` и обратных связей, можно добавлять queryset с фильтрацией |

---

## **3. Проверка запросов**

| Инструмент             | Как использовать                                                                          | Что показывает                                       |
| ---------------------- | ----------------------------------------------------------------------------------------- | ---------------------------------------------------- |
| `QuerySet.explain()`   | `qs = Author.objects.annotate(book_count=Count('book')); print(qs.explain(analyze=True))` | План выполнения SQL, использование индексов, время   |
| Логирование SQL        | Настройка `LOGGING` в `settings.py`                                                       | Все SQL-запросы, время выполнения, дубли             |
| `django-debug-toolbar` | Установка через pip и добавление в `INSTALLED_APPS`                                       | Визуальная панель с запросами, временем, дубликатами |
| `django-silk`          | Профайлер запросов и кода                                                                 | Статистика медленных запросов, анализ ORM vs raw SQL |

---

## **4. Практические советы**

1. Добавляйте **индексы** на поля, используемые в `filter`, `annotate` и `group_by`.
2. Используйте `Count('id')` вместо `Count(*)` для больших таблиц.
3. При больших `ManyToMany` — применяйте `Prefetch` с фильтром, чтобы не загружать лишние объекты.
4. Если ORM слишком сложен для агрегации — применяйте `RawSQL` с подзапросами.
5. Всегда проверяйте **план выполнения через `explain()`**, особенно после добавления новых агрегатов или фильтров.

