# REST API

**REST (Representational State Transfer)** — это архитектурный стиль программного обеспечения,  
созданный для описания архитектуры и руководства разработкой для Всемирной паутины. 

REST оперирует **ресурсами**, каждый из которых имеет уникальный идентификатор (URL).  
Клиент взаимодействует с ресурсами через стандартные HTTP-методы: (`GET`, `POST`, `PUT/PATCH` и `DELETE`).

Архитектурный стиль REST делает акцент на 
- единообразных интерфейсах, 
- независимом развертывании компонентов, 
- масштабируемости взаимодействия между ними 
- и создании многоуровневой архитектуры для поддержки кэширования (для снижения воспринимаемой пользователем задержки), 
- обеспечения безопасности и инкапсуляции устаревших систем.

В основе стиля лежат 6 ограничений, сформулированных Роем Филдингом в его диссертации. 

## Шесть ограничений REST API

### 1. Клиент-серверная архитектура (Client-Server)

- Сервер управляет хранением данных и логикой, клиент — интерфейсом и взаимодействием с пользователем.
- Позволяет независимо развивать клиентскую и серверную части.

---

### 2. Отсутствие состояния (Stateless)

* Каждый запрос от клиента к серверу должен содержать всю информацию для обработки (сессии на сервере не хранятся).
* Сервер не должен помнить предыдущие запросы клиента.
* Пример: вместо хранения логина в сессии, передаём токен в заголовке Authorization при каждом запросе.

---

### 3. Кэширование (Cacheable)

* Ответы сервера должны явно указывать, можно ли их кэшировать.
* Позволяет уменьшить нагрузку на сервер и ускорить ответы.
* Пример: заголовки `Cache-Control` и `ETag` в HTTP.

---

### 4. Единообразие интерфейса (Uniform Interface)

* Основное правило REST — единый и предсказуемый интерфейс для всех ресурсов.
* Состоит из 4 подправил:

  1. **Идентификация ресурсов** (URL для каждого ресурса)
     `/users/123` — конкретный пользователь.
  2. **Манипуляции через представления ресурсов** (HTTP-методы: GET, POST, PUT, DELETE).
  3. **Самоописывающие сообщения** (каждое сообщение содержит всю нужную информацию).
  4. **Гипермедиа как движок состояния приложения** — 
     * Клиент взаимодействует с сервером исключительно через гипермедиа-ссылки, которые сервер включает в свои ответы
     * Это позволяет менять структуру URL или внутреннюю логику сервера, не ломая клиент
     * Клиент не должен заранее знать пути к API; он «путешествует» по ссылкам, которые сервер возвращает в ответах.

---

### 5. Слои системы (Layered System)

* Архитектура может состоять из нескольких слоёв (прокси, балансировщики, кэш-серверы).
* Клиент не должен знать, с каким именно сервером он взаимодействует.

---

### 6. Опционально: Код по требованию (Code on Demand)

* Сервер может передавать исполняемый код клиенту (например, JavaScript), чтобы расширять функционал.
* Используется редко.

