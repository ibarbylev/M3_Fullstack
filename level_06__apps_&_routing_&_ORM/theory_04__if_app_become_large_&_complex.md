## Если приложение вдруг стало большим и сложным

Это случается довольно часто.

### ❓ Как быть?

По-прежнему следовать принципу "разделяй и властвуй":
1. Перенести часть кода во вспомогательные модули (`utils.py`, `service.py` etc.)
1. Вместо модуля создать папку (`views/shop.py`, `views/delivery.py` etc.)
1. Если и это не помогает - разбить на несколько самостоятельных приложений


## Каталог вместо модуля

Один из самых простых, очевидных и безболезненных способов.  

Чтобы не менять импорты в других модулях, необходимо:
1. Создать `__init__.py`
2. Заполнить его импортами из внутренних модулей
3. В каждом внутреннем модуле явно указать импортируемые объекты с помощью `__all__`

## Рассмотрим на примере приложения `myapp`

### Для начала "безумно" усложним приложение
Для этого сначала добавим данные во `views.py` и `urls.py`.

`views.py`
```djangourlpath
class MyAppListView2(ListView):
    model = MyappModel

    def get_context_data(self, *, object_list=None, **kwargs):
        context = super().get_context_data()

        context['active_page'] = 'myapp2'
        return context
```

`urls.py`
```djangourlpath
    path('2/', views.MyAppListView2.as_view(), name='myapp2'),
```

### Теперь изменим структуру views.py

Создадим папку `views` создадим в ней модули:
- `__init__.py`
- `view_1.py`
- `view_2.py`

Заполним `__init__.py`:
```djangourlpath
from views_1 import *
from views_2 import *
```

В 2 последние модуля (`view_1.py` и `view_2.py`) перенесём по одному view, и в начале каждого добавим
`__all__ = ["MyAppListView"]` и `__all__ = ["MyAppListView2"]` соответственно.

Это позволит избежать импорта "всего подряд" при импорте "со звёздочкой":
`from views_1 import *`

Также необходимо будет "поднять" импорт модели на один уровень вверх:
`from ..models import MyappModel`

### Удалим уже ненужный `views.py`

Если всё сделано правильно, то нигде в коде изменения не должны быть замечены.  
И всё продолжит работать как и до изменений.